#include <stdint.h>
#include "main.h"
#include "user_tim.h"

void USER_TIM3_PWM_Init( void ){
	/* STEP 0. Enable the clock signal for the TIM3 and GPIOB peripherals */
	RCC->IOPENR		|=  ( 0x1UL <<  1U );
	RCC->APBENR1	|=  ( 0x1UL <<  1U );

	/* STEP 0. Configure TIM3_CH1 (PB4) to output the PWM signal */
	GPIOB->AFR[0]		&= ~( 0xEUL << 16U );
	GPIOB->AFR[0]		|=  ( 0x1UL << 16U );
	GPIOB->PUPDR  &= ~( 0x3UL <<  8U );
	GPIOB->OTYPER	&= ~( 0x1UL <<  4U );
	GPIOB->MODER  &= ~( 0x1UL <<  8U );
	GPIOB->MODER  |=  ( 0x2UL <<  8U );
	/* STEP 0. Configure TIM3_CH1 (PB5) to output the PWM signal */
	GPIOB->AFR[0]		&= ~( 0xEUL << 20U );
	GPIOB->AFR[0]		|=  ( 0x1UL << 20U );
	GPIOB->PUPDR  &= ~( 0x3UL <<  10U );
	GPIOB->OTYPER	&= ~( 0x1UL <<  5U );
	GPIOB->MODER  &= ~( 0x1UL <<  10U );
	GPIOB->MODER  |=  ( 0x2UL <<  10U );

	GPIOB->AFR[0]		&= ~( 0xEUL << 0U );
		GPIOB->AFR[0]		|=  ( 0x1UL << 0U );
		GPIOB->PUPDR  &= ~( 0x3UL <<  0U );
		GPIOB->OTYPER	&= ~( 0x1UL <<  0U );
		GPIOB->MODER  &= ~( 0x1UL <<  0U );
		GPIOB->MODER  |=  ( 0x2UL <<  0U );

		GPIOB->AFR[0]		&= ~( 0xEUL << 4U );
			GPIOB->AFR[0]		|=  ( 0x1UL << 4U );
			GPIOB->PUPDR  &= ~( 0x3UL <<  2U );
			GPIOB->OTYPER	&= ~( 0x1UL <<  1U );
			GPIOB->MODER  &= ~( 0x1UL <<  2U );
			GPIOB->MODER  |=  ( 0x2UL <<  2U );

	/* STEP 1. Configure the clock source (internal) */
	TIM3->SMCR		&= ~( 0x1UL << 16U )
								&  ~( 0x7UL <<  0U );//		Prescaler is clocked directed by the internal clock

	/* STEP 2. Configure the counter mode, the auto-reload and the overflow UEV-event  */
	TIM3->CR1			&= ~( 0x3UL <<  5U ) //		Selects edge-aligned mode
								&  ~( 0x1UL <<  4U ) //		Counter used as upcounter
								&  ~( 0x1UL <<  2U ) //		UEV can be generated by software
								&  ~( 0x1UL <<  1U );//		Update Event (UEV) enabled
	TIM3->CR1			|=  ( 0x1UL <<  7U );//		Auto-reload register is buffered

	/* STEP 3. Configure the prescaler, the period and the duty cycle register values */
	TIM3->PSC			 = 0U;
	TIM3->ARR			 = 47999U;//	for 1 KHz frequency
	///////////////////////////////////////////////////////////////////////
	TIM3->CCR1		 = USER_Duty_Cycle( 0 );//	for 25% of duty cycle
	TIM3->CCR2		 = USER_Duty_Cycle( 0 );//	for 25% of duty cycle
	TIM3->CCR3		 = USER_Duty_Cycle( 0 );//	for 25% of duty cycle
	TIM3->CCR4		 = USER_Duty_Cycle( 0 );//	for 25% of duty cycle

	///////////////////////////////////////////////////////////////////////
	/* STEP 4. Configure the PWM mode, the compare register load and channel direction */
	TIM3->CCMR1		&= ~( 0x1UL << 16U )
								&  ~( 0x1UL <<  4U ) //		Selects PWM 1 mode
								&  ~( 0x3UL <<  0U );//		Selects CH1 as output

 	TIM3->CCMR1		|=  ( 0x6UL <<  4U ) //		Selects PWM 1 mode
								|   ( 0x1UL <<  3U );//		CCR1 loads on the UEV event

 	///////////////////////////////////////////////////////////////////////

 	TIM3->CCMR1		&= ~( 0x1UL << 24U )
 									&  ~( 0x1UL <<  12U ) //		Selects PWM 1 mode
 									&  ~( 0x3UL <<  8U );//		Selects CH1 as output

 	 TIM3->CCMR1		|=  ( 0x6UL <<  12U ) //		Selects PWM 1 mode
 									|   ( 0x1UL <<  11U );//		CCR1 loads on the UEV event
 	///////////////////////////////////////////////////////////////////////


 	///////////////////////////////////////////////////////////////////////
 	/* STEP 4. Configure the PWM mode, the compare register load and channel direction */
 	TIM3->CCMR2		&= ~( 0x1UL << 16U )
 								&  ~( 0x1UL <<  4U ) //		Selects PWM 1 mode
 								&  ~( 0x3UL <<  0U );//		Selects CH1 as output

  	TIM3->CCMR2		|=  ( 0x6UL <<  4U ) //		Selects PWM 1 mode
 								|   ( 0x1UL <<  3U );//		CCR1 loads on the UEV event

  	///////////////////////////////////////////////////////////////////////

  	TIM3->CCMR2		&= ~( 0x1UL << 24U )
  									&  ~( 0x1UL <<  12U ) //		Selects PWM 1 mode
  									&  ~( 0x3UL <<  8U );//		Selects CH1 as output

  	 TIM3->CCMR2		|=  ( 0x6UL <<  12U ) //		Selects PWM 1 mode
  									|   ( 0x1UL <<  11U );//		CCR1 loads on the UEV event
  	///////////////////////////////////////////////////////////////////////



	/* STEP 5. Generate the UEV-event to load the registers */
	TIM3->EGR			|=  ( 0x1UL <<  0U );

	///////////////////////////////////////////////////////////////////////
	/* STEP 6. Enable the PWM signal output and set the polarity */
	TIM3->CCER		&= ~( 0x1UL <<  3U ) //		for output mode, this bit must be cleared
								&  ~( 0x1UL <<  1U );//		OC1 active high
	TIM3->CCER		|=  ( 0x1UL <<  0U );//		OC1 signal is output on the corresponding pin
	///////////////////////////////////////////////////////////////////////
	TIM3->CCER		&= ~( 0x1UL <<  7U ) //		for output mode, this bit must be cleared
								&  ~( 0x1UL <<  5U );//		OC1 active high
	TIM3->CCER		|=  ( 0x1UL <<  4U );//		OC1 signal is output on the corresponding pin
	///////////////////////////////////////////////////////////////////////
	TIM3->CCER		&= ~( 0x1UL <<  11U ) //		for output mode, this bit must be cleared
									&  ~( 0x1UL <<  9U );//		OC1 active high
	TIM3->CCER		|=  ( 0x1UL <<  8U );//		OC1 signal is output on the corresponding pin
	///////////////////////////////////////////////////////////////////////
	TIM3->CCER		&= ~( 0x1UL <<  15U ) //		for output mode, this bit must be cleared
										&  ~( 0x1UL <<  13U );//		OC1 active high
	TIM3->CCER		|=  ( 0x1UL <<  12U );//		OC1 signal is output on the corresponding pin
	///////////////////////////////////////////////////////////////////////

	/* STEP 7. Enable the Timer to start counting */
	TIM3->CR1			|=  ( 0x1UL <<  0U );
}

void USER_TIM14_Init(void) {
	RCC->APBENR2 |=  (0x1UL <<  15U);
	TIM14->SMCR	 &= ~( 0x1UL << 16U)
				 &  ~( 0x7UL << 0U);
	TIM14->CR1	 &= ~( 0x1UL << 7U)
				 &  ~( 0x3UL << 5U)
				 &  ~( 0x1UL << 4U)
				 &  ~( 0x1UL << 1U);
}

void USER_TIM14_Delay(uint16_t us) {
    TIM14->CR1 &= ~(1UL << 0);           // Deshabilita el timer

    TIM14->PSC = 47;                     // Prescaler: (48 MHz / (47+1)) = 1 MHz → 1 tick = 1 µs
    TIM14->ARR = us;                     // Número de microsegundos a esperar

    TIM14->EGR |= (1UL << 0);            // Generar evento de actualización
    TIM14->SR &= ~(1UL << 0);            // Limpia bandera de actualización
    TIM14->CR1 |= (1UL << 0);            // Habilita el timer

    while (!(TIM14->SR & (1UL << 0)));   // Espera a que llegue el overflow

    TIM14->CR1 &= ~(1UL << 0);           // Deshabilita el timer
    TIM14->SR &= ~(1UL << 0);            // Limpia bandera nuevamente
}

void USER_TIM17_Init_Timer( void ){
    RCC->APBENR2 |=   ( 0x1UL << 18U );//  TIM17 clock source enabled
    TIM17->CR1   &=  ~( 0x1UL <<  7U )//   auto-reload reg is not buffered
                 &   ~( 0x1UL <<  1U );//  update event (UEV) enabled
    TIM17->PSC   =    1499U;//             time range: 32us to 2s
    TIM17->ARR   =    65535U;//            maximum count
    TIM17->SR   &=  ~( 0x1UL <<  0U );//   clear TIM overflow-event flag
    TIM17->CR1  |=   ( 0x1UL <<  0U );//   timer enabled
}


void update_cycle(uint8_t duty, uint8_t pin){
	switch(pin){
	case 1:
		TIM3->CCR1		 = USER_Duty_Cycle( duty );//	for 25% of duty cycle
		break;
	case 2:
		TIM3->CCR2		 = USER_Duty_Cycle( duty );//	for 25% of duty cycle
		break;
	case 3:
		TIM3->CCR3		 = USER_Duty_Cycle( duty );//	for 25% of duty cycle
		break;
	case 4:
			TIM3->CCR4		 = USER_Duty_Cycle( duty );//	for 25% of duty cycle
			break;
	default:
	            break;

	}
}

uint16_t USER_Duty_Cycle( uint8_t duty ){
	/* duty can be a value between 0% and 100% */
	if( duty <= 100 )
		return (( duty / 100.0 )*( TIM3->ARR + 1));
	else
		return 0;
}
